{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isNumber, $, isString } from '../utils/util';\nimport throwError from '../utils/error';\nimport { defineComponent, ref, reactive, computed, watch, onMounted, onBeforeUnmount, h, withModifiers, getCurrentInstance, onUpdated, resolveDynamicComponent, nextTick } from 'vue';\nimport memo from 'lodash/memoize';\nimport isServer from '../utils/isServer';\nimport { cAF, rAF } from '../utils/raf';\nimport { on, off } from '../utils/dom';\nimport getScrollBarWidth from '../utils/scrollbar-width';\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\nconst EMPTY_OBJ = process.env.NODE_ENV !== 'production' ? Object.freeze({}) : {};\nconst EMPTY_ARR = process.env.NODE_ENV !== 'production' ? Object.freeze([]) : [];\nconst NOOP = () => {};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isFunction = val => typeof val === 'function';\nconst isObject = val => val !== null && typeof val === 'object';\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;\nconst ITEM_RENDER_EVT = \"item-rendered\";\nconst SCROLL_EVT = \"scroll\";\nconst FORWARD = \"forward\";\nconst BACKWARD = \"backward\";\nconst AUTO_ALIGNMENT = \"auto\";\nconst SMART_ALIGNMENT = \"smart\";\nconst START_ALIGNMENT = \"start\";\nconst CENTERED_ALIGNMENT = \"center\";\nconst END_ALIGNMENT = \"end\";\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\nconst LTR = \"ltr\";\nconst RTL = \"rtl\";\nconst RTL_OFFSET_NAG = \"negative\";\nconst RTL_OFFSET_POS_ASC = \"positive-ascending\";\nconst RTL_OFFSET_POS_DESC = \"positive-descending\";\nconst DefaultListProps = {\n  cache: {\n    type: Number,\n    default: 2\n  },\n  className: {\n    type: String,\n    default: \"\"\n  },\n  containerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  data: {\n    type: [Array],\n    default: () => []\n  },\n  direction: {\n    type: String,\n    default: \"ltr\",\n    validator: val => {\n      return val === LTR || val === RTL;\n    }\n  },\n  estimatedItemSize: {\n    type: [Number]\n  },\n  height: {\n    type: [String, Number],\n    required: true\n  },\n  layout: {\n    type: String,\n    default: VERTICAL\n  },\n  initScrollOffset: {\n    type: Number,\n    default: 0\n  },\n  innerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  total: {\n    type: Number,\n    required: true\n  },\n  itemSize: {\n    type: [Number, Function],\n    required: true\n  },\n  style: {\n    type: [Object, String, Array],\n    default: () => ({})\n  },\n  useIsScrolling: {\n    type: Boolean,\n    default: false\n  },\n  width: {\n    type: [Number, String],\n    required: true\n  }\n};\nconst DefaultGridProps = {\n  className: DefaultListProps.className,\n  columnCache: DefaultListProps.cache,\n  columnWidth: DefaultListProps.itemSize,\n  containerElement: DefaultListProps.containerElement,\n  data: DefaultListProps.data,\n  direction: DefaultListProps.direction,\n  estimatedColumnWidth: DefaultListProps.estimatedItemSize,\n  estimatedRowHeight: DefaultListProps.estimatedItemSize,\n  height: __spreadProps(__spreadValues({}, DefaultListProps.height), {\n    validator: val => isNumber(val)\n  }),\n  initScrollLeft: DefaultListProps.initScrollOffset,\n  initScrollTop: DefaultListProps.initScrollOffset,\n  innerElement: DefaultListProps.innerElement,\n  rowCache: DefaultListProps.cache,\n  rowHeight: DefaultListProps.itemSize,\n  style: DefaultListProps.style,\n  useIsScrolling: DefaultListProps.useIsScrolling,\n  width: __spreadProps(__spreadValues({}, DefaultListProps.width), {\n    validator: val => {\n      return isNumber(val);\n    }\n  }),\n  totalColumn: DefaultListProps.total,\n  totalRow: DefaultListProps.total\n};\nconst DefaultScrollBarProps = {\n  layout: DefaultListProps.layout,\n  total: Number,\n  ratio: Number,\n  clientSize: Number,\n  scrollFrom: Number,\n  visible: Boolean\n};\nconst ScrollbarDirKey = {\n  [HORIZONTAL]: \"left\",\n  [VERTICAL]: \"top\"\n};\nconst SCROLLBAR_MIN_SIZE = 20;\nconst getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;\nconst isHorizontal = dir => dir === LTR || dir === RTL || dir === HORIZONTAL;\nconst isRTL = dir => dir === RTL;\nlet cachedRTLResult = null;\nfunction getRTLOffsetType(recalculate = false) {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = RTL_OFFSET_POS_DESC;\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = RTL_OFFSET_NAG;\n      } else {\n        cachedRTLResult = RTL_OFFSET_POS_ASC;\n      }\n    }\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n  return cachedRTLResult;\n}\nfunction renderThumbStyle({\n  move,\n  size,\n  bar\n}, layout) {\n  const style = {};\n  const translate = `translate${bar.axis}(${move}px)`;\n  style[bar.size] = size;\n  style.transform = translate;\n  style.msTransform = translate;\n  style.webkitTransform = translate;\n  if (layout === \"horizontal\") {\n    style.height = \"100%\";\n  } else {\n    style.width = \"100%\";\n  }\n  return style;\n}\nconst isFF = typeof navigator !== \"undefined\" && isObject(navigator) && /Firefox/i.test(navigator.userAgent);\nconst LayoutKeys = {\n  [HORIZONTAL]: \"deltaX\",\n  [VERTICAL]: \"deltaY\"\n};\nconst useWheel = ({\n  atEndEdge,\n  atStartEdge,\n  layout\n}, onWheelDelta) => {\n  let frameHandle = null;\n  let offset = 0;\n  const hasReachedEdge = offset2 => {\n    const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;\n    return edgeReached;\n  };\n  const onWheel = e => {\n    cAF(frameHandle);\n    const newOffset = e[LayoutKeys[layout.value]];\n    if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset)) return;\n    offset += newOffset;\n    if (!isFF) {\n      e.preventDefault();\n    }\n    frameHandle = rAF(() => {\n      onWheelDelta(offset);\n      offset = 0;\n    });\n  };\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\nconst BAR_MAP = {\n  vertical: {\n    offset: \"offsetHeight\",\n    scroll: \"scrollTop\",\n    scrollSize: \"scrollHeight\",\n    size: \"height\",\n    key: \"vertical\",\n    axis: \"Y\",\n    client: \"clientY\",\n    direction: \"top\"\n  },\n  horizontal: {\n    offset: \"offsetWidth\",\n    scroll: \"scrollLeft\",\n    scrollSize: \"scrollWidth\",\n    size: \"width\",\n    key: \"horizontal\",\n    axis: \"X\",\n    client: \"clientX\",\n    direction: \"left\"\n  }\n};\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: DefaultScrollBarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n  setup(props, {\n    emit\n  }) {\n    const trackRef = ref(null);\n    const thumbRef = ref(null);\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackStyle = computed(() => ({\n      display: props.visible ? null : \"none\",\n      position: \"absolute\",\n      width: HORIZONTAL === props.layout ? \"100%\" : \"6px\",\n      height: HORIZONTAL === props.layout ? \"6px\" : \"100%\",\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }));\n    const thumbSize = computed(() => {\n      if (props.ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (props.ratio >= 50) {\n        return props.ratio * props.clientSize / 100;\n      }\n      const SCROLLBAR_MAX_SIZE = props.clientSize / 3;\n      return Math.floor(Math.min(Math.max(props.ratio * props.clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - 4));\n    const attachEvents = () => {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      const thumbEl = thumbRef.value;\n      onselectstartStore = document.onselectstart;\n      document.onselectstart = () => false;\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n    const detachEvents = () => {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = thumbRef.value;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n    const onThumbMouseDown = e => {\n      e.stopImmediatePropagation();\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n    const onMouseMove = e => {\n      const {\n        isDragging\n      } = state;\n      if (!isDragging) return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage) return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(2, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n    const onScrollbarTouchStart = e => e.preventDefault();\n    watch(() => props.scrollFrom, v => {\n      if (state.isDragging) return;\n      state.traveled = Math.ceil(v * props.clientSize / (props.clientSize / totalSteps.value));\n    });\n    onMounted(() => {\n      if (isServer) return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(() => {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(NOOP, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, null));\n    };\n  }\n});\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) {\n    if (__propIsEnum$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, {\n      emit,\n      expose\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const scrollbarRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false\n      });\n      const itemsToRender = computed(() => {\n        const {\n          total,\n          cache\n        } = props;\n        const {\n          isScrolling,\n          scrollDir,\n          scrollOffset\n        } = $(states);\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getStartIndexForOffset(props, scrollOffset, $(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, $(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, $(dynamicSizeCache)));\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n      const windowStyle = computed(() => [{\n        position: \"relative\",\n        overflow: \"hidden\",\n        WebkitOverflowScrolling: \"touch\",\n        willChange: \"transform\"\n      }, __spreadValues$1({\n        direction: props.direction,\n        height: isNumber(props.height) ? `${props.height}px` : props.height,\n        width: isNumber(props.width) ? `${props.width}px` : props.width\n      }, props.style)]);\n      const innerStyle = computed(() => {\n        const size = $(estimatedTotalSize);\n        const horizontal = $(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const {\n        onWheel\n      } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, offset => {\n        var _a, _b;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n      const emitEvents = () => {\n        const {\n          total\n        } = props;\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = $(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n        const {\n          scrollDir,\n          scrollOffset,\n          updateRequested\n        } = $(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n      const scrollVertically = e => {\n        const {\n          clientHeight,\n          scrollHeight,\n          scrollTop\n        } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollHorizontally = e => {\n        const {\n          clientWidth,\n          scrollLeft,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n        const {\n          direction\n        } = props;\n        let scrollOffset = scrollLeft;\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n            case RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      const onScroll = e => {\n        $(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n      const scrollTo = offset => {\n        offset = Math.max(offset, 0);\n        if (offset === $(states).scrollOffset) {\n          return;\n        }\n        states.value = __spreadProps$1(__spreadValues$1({}, $(states)), {\n          scrollOffset: offset,\n          scrollDir: getScrollDir($(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const {\n          scrollOffset\n        } = $(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, $(dynamicSizeCache)));\n      };\n      const getItemStyle = idx => {\n        const {\n          direction,\n          itemSize,\n          layout\n        } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, $(dynamicSizeCache));\n          const size = getItemSize(props, idx, $(dynamicSizeCache));\n          const horizontal = $(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n        return style;\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (isServer) return;\n        const {\n          initScrollOffset\n        } = props;\n        const windowElement = $(windowRef);\n        if (isNumber(initScrollOffset) && windowElement !== null) {\n          if ($(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction,\n          layout\n        } = props;\n        const {\n          scrollOffset,\n          updateRequested\n        } = $(states);\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\":\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n                case \"positive-ascending\":\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n                default:\n                  {\n                    const {\n                      clientWidth,\n                      scrollWidth\n                    } = windowElement;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n        visible: true\n      });\n      const listContainer = h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? {\n        default: () => [InnerNode]\n      } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: \"el-vl__wrapper\"\n      }, [listContainer, scrollbar]);\n    }\n  });\n};\nconst FixedSizeList = createList({\n  name: \"ElFixedSizeList\",\n  getItemOffset: ({\n    itemSize\n  }, index) => index * itemSize,\n  getItemSize: ({\n    itemSize\n  }) => itemSize,\n  getEstimatedTotalSize: ({\n    total,\n    itemSize\n  }) => itemSize * total,\n  getOffset: ({\n    height,\n    total,\n    itemSize,\n    layout,\n    width\n  }, index, alignment, scrollOffset) => {\n    const size = isHorizontal(layout) ? width : height;\n    if (process.env.ENV !== \"production\" && isString(size)) {\n      throwError(\"[ElVirtualList]\", `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `);\n    }\n    const lastItemOffset = Math.max(0, total * itemSize - size);\n    const maxOffset = Math.min(lastItemOffset, index * itemSize);\n    const minOffset = Math.max(0, (index + 1) * itemSize - size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0;\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: ({\n    total,\n    itemSize\n  }, offset) => Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize))),\n  getStopIndexForStartIndex: ({\n    height,\n    total,\n    itemSize,\n    layout,\n    width\n  }, startIndex, scrollOffset) => {\n    const offset = startIndex * itemSize;\n    const size = isHorizontal(layout) ? width : height;\n    const numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n  initCache() {\n    return void 0;\n  },\n  clearCache: true,\n  validateProps() {}\n});\nconst SCOPE = \"ElDynamicSizeList\";\nconst getItemFromCache = (props, index, listCache) => {\n  const {\n    itemSize\n  } = props;\n  const {\n    items,\n    lastVisitedIndex\n  } = listCache;\n  if (index > lastVisitedIndex) {\n    let offset = 0;\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = itemSize(i);\n      items[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    listCache.lastVisitedIndex = index;\n  }\n  return items[index];\n};\nconst findItem = (props, listCache, offset) => {\n  const {\n    items,\n    lastVisitedIndex\n  } = listCache;\n  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\nconst bs = (props, listCache, low, high, offset) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, listCache).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n  return Math.max(0, low - 1);\n};\nconst es = (props, listCache, index, offset) => {\n  const {\n    total\n  } = props;\n  let exponent = 1;\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\nconst getEstimatedTotalSize = ({\n  total\n}, {\n  items,\n  estimatedItemSize,\n  lastVisitedIndex\n}) => {\n  let totalSizeOfMeasuredItems = 0;\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n  const numUnmeasuredItems = total - lastVisitedIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\nconst DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: (props, index, listCache) => getItemFromCache(props, index, listCache).offset,\n  getItemSize: (_, index, {\n    items\n  }) => items[index].size,\n  getEstimatedTotalSize,\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const {\n      height,\n      layout,\n      width\n    } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, index, listCache);\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    const minOffset = Math.max(0, item.offset - size + item.size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n      case CENTERED_ALIGNMENT:\n        {\n          return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: (props, offset, listCache) => findItem(props, listCache, offset),\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const {\n      height,\n      total,\n      layout,\n      width\n    } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, startIndex, listCache);\n    const maxOffset = scrollOffset + size;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n    return stopIndex;\n  },\n  initCache({\n    estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n    cache.clearCacheAfterIndex = (index, forceUpdate = true) => {\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      instance.exposed.getItemStyleCache(-1);\n      if (forceUpdate) {\n        instance.proxy.$forceUpdate();\n      }\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: ({\n    itemSize\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `);\n      }\n    }\n  }\n});\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) {\n    if (__propIsEnum$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, {\n      emit,\n      expose\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const columnsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          columnCache\n        } = props;\n        const {\n          isScrolling,\n          xAxisScrollDir,\n          scrollLeft\n        } = $(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, $(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, $(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const rowsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          rowCache\n        } = props;\n        const {\n          isScrolling,\n          yAxisScrollDir,\n          scrollTop\n        } = $(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, $(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, $(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, $(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, $(cache)));\n      const windowStyle = computed(() => [{\n        position: \"relative\",\n        overflow: \"auto\",\n        WebkitOverflowScrolling: \"touch\",\n        willChange: \"transform\"\n      }, __spreadValues$2({\n        direction: props.direction,\n        height: isNumber(props.height) ? `${props.height}px` : props.height,\n        width: isNumber(props.width) ? `${props.width}px` : props.width\n      }, props.style)]);\n      const innerStyle = computed(() => {\n        const width = `${$(estimatedTotalWidth)}px`;\n        const height = `${$(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n      const emitEvents = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = $(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = $(rowsToRender);\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir\n        } = $(states);\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n      const onScroll = e => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n        let _scrollLeft = scrollLeft;\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n      const scrollTo = ({\n        scrollLeft,\n        scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n        const _states = $(states);\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = $(states);\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth();\n        const _cache = $(cache);\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const {\n          columnWidth,\n          direction,\n          rowHeight\n        } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, $(cache));\n          const _cache = $(cache);\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (isServer) return;\n        const {\n          initScrollLeft,\n          initScrollTop\n        } = props;\n        const windowElement = $(windowRef);\n        if (windowElement !== null) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction\n        } = props;\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested\n        } = $(states);\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n              case RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n              default:\n                {\n                  const {\n                    clientWidth,\n                    scrollWidth\n                  } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      const api = {\n        windowStyle,\n        windowRef,\n        columnsToRender,\n        innerRef,\n        innerStyle,\n        states,\n        rowsToRender,\n        getItemStyle,\n        onScroll,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        containerElement,\n        columnsToRender,\n        data,\n        getItemStyle,\n        innerElement,\n        innerStyle,\n        rowsToRender,\n        onScroll,\n        states,\n        useIsScrolling,\n        windowStyle,\n        totalColumn,\n        totalRow\n      } = ctx;\n      const [columnStart, columnEnd] = columnsToRender;\n      const [rowStart, rowEnd] = rowsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (totalRow > 0 && totalColumn > 0) {\n        for (let row = rowStart; row <= rowEnd; row++) {\n          for (let column = columnStart; column <= columnEnd; column++) {\n            children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n              columnIndex: column,\n              data,\n              key: column,\n              isScrolling: useIsScrolling ? states.isScrolling : void 0,\n              style: getItemStyle(row, column),\n              rowIndex: row\n            }));\n          }\n        }\n      }\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      return h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        ref: \"windowRef\"\n      }, !isString(Container) ? {\n        default: () => InnerNode\n      } : InnerNode);\n    }\n  });\n};\nconst SCOPE$1 = \"ElFixedSizeGrid\";\nconst FixedSizeGrid = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: ({\n    columnWidth\n  }, index) => [columnWidth, index * columnWidth],\n  getRowPosition: ({\n    rowHeight\n  }, index) => [rowHeight, index * rowHeight],\n  getEstimatedTotalHeight: ({\n    totalRow,\n    rowHeight\n  }) => rowHeight * totalRow,\n  getEstimatedTotalWidth: ({\n    totalColumn,\n    columnWidth\n  }) => columnWidth * totalColumn,\n  getColumnOffset: ({\n    totalColumn,\n    columnWidth,\n    width\n  }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {\n    width = Number(width);\n    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0;\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset;\n        } else {\n          return middleOffset;\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getRowOffset: ({\n    rowHeight,\n    height,\n    totalRow\n  }, rowIndex, align, scrollTop, _, scrollBarWidth) => {\n    height = Number(height);\n    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0;\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset;\n        } else {\n          return middleOffset;\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getColumnStartIndexForOffset: ({\n    columnWidth,\n    totalColumn\n  }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),\n  getColumnStopIndexForStartIndex: ({\n    columnWidth,\n    totalColumn,\n    width\n  }, startIndex, scrollLeft) => {\n    const left = startIndex * columnWidth;\n    const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: ({\n    rowHeight,\n    totalRow\n  }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),\n  getRowStopIndexForStartIndex: ({\n    rowHeight,\n    totalRow,\n    height\n  }, startIndex, scrollTop) => {\n    const top = startIndex * rowHeight;\n    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: () => void 0,\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nconst {\n  max,\n  min,\n  floor\n} = Math;\nconst SCOPE$2 = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\nconst getItemFromCache$1 = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [gridCache[type], props[ACCESS_SIZER_KEY_MAP[type]], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n  if (index > lastVisited) {\n    let offset = 0;\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n  return cachedItems[index];\n};\nconst bs$1 = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache$1(props, mid, gridCache, type).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return max(0, low - 1);\n};\nconst es$1 = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n  while (idx < total && getItemFromCache$1(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n  return bs$1(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\nconst findItem$1 = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [gridCache[type], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n  if (lastVisitedItemOffset >= offset) {\n    return bs$1(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n  return es$1(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\nconst getEstimatedTotalHeight = ({\n  totalRow\n}, {\n  estimatedRowHeight,\n  lastVisitedRowIndex,\n  row\n}) => {\n  let sizeOfVisitedRows = 0;\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\nconst getEstimatedTotalWidth = ({\n  totalColumn\n}, {\n  column,\n  estimatedColumnWidth,\n  lastVisitedColumnIndex\n}) => {\n  let sizeOfVisitedColumns = 0;\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [size, estimatedSizeAssociates] = [type === \"row\" ? props.height : props.width, ACCESS_ESTIMATED_SIZE_KEY_MAP[type]];\n  const item = getItemFromCache$1(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n  switch (alignment) {\n    case START_ALIGNMENT:\n      {\n        return maxOffset;\n      }\n    case END_ALIGNMENT:\n      {\n        return minOffset;\n      }\n    case CENTERED_ALIGNMENT:\n      {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n    case AUTO_ALIGNMENT:\n    default:\n      {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n  }\n};\nconst FixedSizeGrid$1 = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem$1(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache$1(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, startIndex, cache, \"column\").size;\n    }\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem$1(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const {\n      totalRow,\n      height\n    } = props;\n    const item = getItemFromCache$1(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, stopIndex, cache, \"row\").size;\n    }\n    return stopIndex;\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nexport { FixedSizeGrid$1 as DynamicSizeGrid, DynamicSizeList, FixedSizeGrid, FixedSizeList };","map":{"version":3,"names":["isNumber","$","isString","throwError","defineComponent","ref","reactive","computed","watch","onMounted","onBeforeUnmount","h","withModifiers","getCurrentInstance","onUpdated","resolveDynamicComponent","nextTick","memo","isServer","cAF","rAF","on","off","getScrollBarWidth","EMPTY_OBJ","process","env","NODE_ENV","Object","freeze","EMPTY_ARR","NOOP","hasOwnProperty","prototype","hasOwn","val","key","call","isFunction","isObject","__defProp","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","value","enumerable","configurable","writable","__spreadValues","a","b","prop","__spreadProps","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","ITEM_RENDER_EVT","SCROLL_EVT","FORWARD","BACKWARD","AUTO_ALIGNMENT","SMART_ALIGNMENT","START_ALIGNMENT","CENTERED_ALIGNMENT","END_ALIGNMENT","HORIZONTAL","VERTICAL","LTR","RTL","RTL_OFFSET_NAG","RTL_OFFSET_POS_ASC","RTL_OFFSET_POS_DESC","DefaultListProps","cache","type","Number","default","className","String","containerElement","data","Array","direction","validator","estimatedItemSize","height","required","layout","initScrollOffset","innerElement","total","itemSize","Function","style","useIsScrolling","Boolean","width","DefaultGridProps","columnCache","columnWidth","estimatedColumnWidth","estimatedRowHeight","initScrollLeft","initScrollTop","rowCache","rowHeight","totalColumn","totalRow","DefaultScrollBarProps","ratio","clientSize","scrollFrom","visible","ScrollbarDirKey","SCROLLBAR_MIN_SIZE","getScrollDir","prev","cur","isHorizontal","dir","isRTL","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","overflow","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","renderThumbStyle","move","size","bar","translate","axis","transform","msTransform","webkitTransform","isFF","navigator","test","userAgent","LayoutKeys","useWheel","atEndEdge","atStartEdge","onWheelDelta","frameHandle","offset","hasReachedEdge","offset2","edgeReached","onWheel","e","newOffset","preventDefault","BAR_MAP","vertical","scroll","scrollSize","client","horizontal","ScrollBar","name","props","emits","setup","emit","trackRef","thumbRef","onselectstartStore","state","isDragging","traveled","trackStyle","display","position","right","bottom","borderRadius","thumbSize","POSITIVE_INFINITY","SCROLLBAR_MAX_SIZE","Math","floor","min","max","thumbStyle","isFinite","thumb","totalSteps","attachEvents","window","onMouseMove","onMouseUp","thumbEl","onselectstart","detachEvents","onThumbMouseDown","stopImmediatePropagation","ctrlKey","includes","button","currentTarget","getBoundingClientRect","prevPage","thumbClickPosition","distance","onScrollbarTouchStart","v","ceil","role","class","onMousedown","__defProp$1","__defProps$1","__getOwnPropDescs$1","__getOwnPropSymbols$1","__hasOwnProp$1","__propIsEnum$1","__defNormalProp$1","__spreadValues$1","__spreadProps$1","createList","getOffset","getItemSize","getItemOffset","getEstimatedTotalSize","getStartIndexForOffset","getStopIndexForStartIndex","initCache","clearCache","validateProps","expose","instance","dynamicSizeCache","windowRef","innerRef","scrollbarRef","states","isScrolling","scrollDir","scrollOffset","updateRequested","isScrollbarDragging","itemsToRender","startIndex","stopIndex","cacheBackward","cacheForward","estimatedTotalSize","_isHorizontal","windowStyle","WebkitOverflowScrolling","willChange","pointerEvents","_a","_b","scrollTo","emitEvents","cacheStart","cacheEnd","visibleStart","visibleEnd","scrollVertically","clientHeight","scrollHeight","scrollTop","_states","resetIsScrolling","scrollHorizontally","clientWidth","scrollWidth","onScroll","onScrollbarScroll","distanceToGo","getItemStyleCache","_","__","___","scrollToItem","idx","alignment","getItemStyle","itemStyleCache","isRtl","offsetHorizontal","left","top","windowElement","api","render","ctx","$slots","start","end","Container","Inner","children","i","push","index","InnerNode","scrollbar","listContainer","FixedSizeList","ENV","lastItemOffset","maxOffset","minOffset","middleOffset","round","numVisibleItems","SCOPE","getItemFromCache","listCache","items","lastVisitedIndex","item","findItem","lastVisitedOffset","bs","es","low","high","mid","currentOffset","exponent","totalSizeOfMeasuredItems","numUnmeasuredItems","totalSizeOfUnmeasuredItems","DynamicSizeList","clearCacheAfterIndex","forceUpdate","exposed","proxy","$forceUpdate","__defProp$2","__defProps$2","__getOwnPropDescs$2","__getOwnPropSymbols$2","__hasOwnProp$2","__propIsEnum$2","__defNormalProp$2","__spreadValues$2","__spreadProps$2","createGrid","getColumnPosition","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getEstimatedTotalHeight","getEstimatedTotalWidth","getColumnOffset","getRowOffset","getRowPosition","getRowStartIndexForOffset","getRowStopIndexForStartIndex","xAxisScrollDir","yAxisScrollDir","columnsToRender","rowsToRender","estimatedTotalHeight","estimatedTotalWidth","columnCacheStart","columnCacheEnd","columnVisibleStart","columnVisibleEnd","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","_scrollLeft","rowIndex","columnIdx","scrollBarWidth","_cache","estimatedHeight","estimatedWidth","columnIndex","rtl","columnStart","columnEnd","rowStart","rowEnd","row","column","SCOPE$1","FixedSizeGrid","lastColumnOffset","align","lastRowOffset","visibleColumnsCount","numVisibleRows","SCOPE$2","ACCESS_SIZER_KEY_MAP","ACCESS_LAST_VISITED_KEY_MAP","getItemFromCache$1","gridCache","cachedItems","sizer","lastVisited","bs$1","es$1","findItem$1","lastVisitedItemOffset","lastVisitedRowIndex","sizeOfVisitedRows","unvisitedItems","sizeOfUnvisitedItems","lastVisitedColumnIndex","sizeOfVisitedColumns","ACCESS_ESTIMATED_SIZE_KEY_MAP","estimatedSizeAssociates","estimatedSize","FixedSizeGrid$1","DynamicSizeGrid"],"sources":["/home/jisra/Documents/escom/is/is_vue_frontend/node_modules/element-plus/es/el-virtual-list/index.js"],"sourcesContent":["import { isNumber, $, isString } from '../utils/util';\nimport throwError from '../utils/error';\nimport { defineComponent, ref, reactive, computed, watch, onMounted, onBeforeUnmount, h, withModifiers, getCurrentInstance, onUpdated, resolveDynamicComponent, nextTick } from 'vue';\nimport memo from 'lodash/memoize';\nimport isServer from '../utils/isServer';\nimport { cAF, rAF } from '../utils/raf';\nimport { on, off } from '../utils/dom';\nimport getScrollBarWidth from '../utils/scrollbar-width';\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;\nconst ITEM_RENDER_EVT = \"item-rendered\";\nconst SCROLL_EVT = \"scroll\";\nconst FORWARD = \"forward\";\nconst BACKWARD = \"backward\";\nconst AUTO_ALIGNMENT = \"auto\";\nconst SMART_ALIGNMENT = \"smart\";\nconst START_ALIGNMENT = \"start\";\nconst CENTERED_ALIGNMENT = \"center\";\nconst END_ALIGNMENT = \"end\";\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\nconst LTR = \"ltr\";\nconst RTL = \"rtl\";\nconst RTL_OFFSET_NAG = \"negative\";\nconst RTL_OFFSET_POS_ASC = \"positive-ascending\";\nconst RTL_OFFSET_POS_DESC = \"positive-descending\";\nconst DefaultListProps = {\n  cache: {\n    type: Number,\n    default: 2\n  },\n  className: {\n    type: String,\n    default: \"\"\n  },\n  containerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  data: {\n    type: [Array],\n    default: () => []\n  },\n  direction: {\n    type: String,\n    default: \"ltr\",\n    validator: (val) => {\n      return val === LTR || val === RTL;\n    }\n  },\n  estimatedItemSize: {\n    type: [Number]\n  },\n  height: {\n    type: [String, Number],\n    required: true\n  },\n  layout: {\n    type: String,\n    default: VERTICAL\n  },\n  initScrollOffset: {\n    type: Number,\n    default: 0\n  },\n  innerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  total: {\n    type: Number,\n    required: true\n  },\n  itemSize: {\n    type: [Number, Function],\n    required: true\n  },\n  style: {\n    type: [Object, String, Array],\n    default: () => ({})\n  },\n  useIsScrolling: {\n    type: Boolean,\n    default: false\n  },\n  width: {\n    type: [Number, String],\n    required: true\n  }\n};\nconst DefaultGridProps = {\n  className: DefaultListProps.className,\n  columnCache: DefaultListProps.cache,\n  columnWidth: DefaultListProps.itemSize,\n  containerElement: DefaultListProps.containerElement,\n  data: DefaultListProps.data,\n  direction: DefaultListProps.direction,\n  estimatedColumnWidth: DefaultListProps.estimatedItemSize,\n  estimatedRowHeight: DefaultListProps.estimatedItemSize,\n  height: __spreadProps(__spreadValues({}, DefaultListProps.height), {\n    validator: (val) => isNumber(val)\n  }),\n  initScrollLeft: DefaultListProps.initScrollOffset,\n  initScrollTop: DefaultListProps.initScrollOffset,\n  innerElement: DefaultListProps.innerElement,\n  rowCache: DefaultListProps.cache,\n  rowHeight: DefaultListProps.itemSize,\n  style: DefaultListProps.style,\n  useIsScrolling: DefaultListProps.useIsScrolling,\n  width: __spreadProps(__spreadValues({}, DefaultListProps.width), {\n    validator: (val) => {\n      return isNumber(val);\n    }\n  }),\n  totalColumn: DefaultListProps.total,\n  totalRow: DefaultListProps.total\n};\nconst DefaultScrollBarProps = {\n  layout: DefaultListProps.layout,\n  total: Number,\n  ratio: Number,\n  clientSize: Number,\n  scrollFrom: Number,\n  visible: Boolean\n};\nconst ScrollbarDirKey = {\n  [HORIZONTAL]: \"left\",\n  [VERTICAL]: \"top\"\n};\nconst SCROLLBAR_MIN_SIZE = 20;\n\nconst getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;\nconst isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;\nconst isRTL = (dir) => dir === RTL;\nlet cachedRTLResult = null;\nfunction getRTLOffsetType(recalculate = false) {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = RTL_OFFSET_POS_DESC;\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = RTL_OFFSET_NAG;\n      } else {\n        cachedRTLResult = RTL_OFFSET_POS_ASC;\n      }\n    }\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n  return cachedRTLResult;\n}\nfunction renderThumbStyle({ move, size, bar }, layout) {\n  const style = {};\n  const translate = `translate${bar.axis}(${move}px)`;\n  style[bar.size] = size;\n  style.transform = translate;\n  style.msTransform = translate;\n  style.webkitTransform = translate;\n  if (layout === \"horizontal\") {\n    style.height = \"100%\";\n  } else {\n    style.width = \"100%\";\n  }\n  return style;\n}\nconst isFF = typeof navigator !== \"undefined\" && isObject(navigator) && /Firefox/i.test(navigator.userAgent);\n\nconst LayoutKeys = {\n  [HORIZONTAL]: \"deltaX\",\n  [VERTICAL]: \"deltaY\"\n};\nconst useWheel = ({\n  atEndEdge,\n  atStartEdge,\n  layout\n}, onWheelDelta) => {\n  let frameHandle = null;\n  let offset = 0;\n  const hasReachedEdge = (offset2) => {\n    const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;\n    return edgeReached;\n  };\n  const onWheel = (e) => {\n    cAF(frameHandle);\n    const newOffset = e[LayoutKeys[layout.value]];\n    if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset))\n      return;\n    offset += newOffset;\n    if (!isFF) {\n      e.preventDefault();\n    }\n    frameHandle = rAF(() => {\n      onWheelDelta(offset);\n      offset = 0;\n    });\n  };\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\n\nconst BAR_MAP = {\n  vertical: {\n    offset: \"offsetHeight\",\n    scroll: \"scrollTop\",\n    scrollSize: \"scrollHeight\",\n    size: \"height\",\n    key: \"vertical\",\n    axis: \"Y\",\n    client: \"clientY\",\n    direction: \"top\"\n  },\n  horizontal: {\n    offset: \"offsetWidth\",\n    scroll: \"scrollLeft\",\n    scrollSize: \"scrollWidth\",\n    size: \"width\",\n    key: \"horizontal\",\n    axis: \"X\",\n    client: \"clientX\",\n    direction: \"left\"\n  }\n};\n\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: DefaultScrollBarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n  setup(props, { emit }) {\n    const trackRef = ref(null);\n    const thumbRef = ref(null);\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackStyle = computed(() => ({\n      display: props.visible ? null : \"none\",\n      position: \"absolute\",\n      width: HORIZONTAL === props.layout ? \"100%\" : \"6px\",\n      height: HORIZONTAL === props.layout ? \"6px\" : \"100%\",\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }));\n    const thumbSize = computed(() => {\n      if (props.ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (props.ratio >= 50) {\n        return props.ratio * props.clientSize / 100;\n      }\n      const SCROLLBAR_MAX_SIZE = props.clientSize / 3;\n      return Math.floor(Math.min(Math.max(props.ratio * props.clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - 4));\n    const attachEvents = () => {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      const thumbEl = thumbRef.value;\n      onselectstartStore = document.onselectstart;\n      document.onselectstart = () => false;\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n    const detachEvents = () => {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = thumbRef.value;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n    const onThumbMouseDown = (e) => {\n      e.stopImmediatePropagation();\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n    const onMouseMove = (e) => {\n      const { isDragging } = state;\n      if (!isDragging)\n        return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage)\n        return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(2, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n    const onScrollbarTouchStart = (e) => e.preventDefault();\n    watch(() => props.scrollFrom, (v) => {\n      if (state.isDragging)\n        return;\n      state.traveled = Math.ceil(v * props.clientSize / (props.clientSize / totalSteps.value));\n    });\n    onMounted(() => {\n      if (isServer)\n        return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(() => {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(NOOP, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, null));\n    };\n  }\n});\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const scrollbarRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false\n      });\n      const itemsToRender = computed(() => {\n        const { total, cache } = props;\n        const { isScrolling, scrollDir, scrollOffset } = $(states);\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getStartIndexForOffset(props, scrollOffset, $(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, $(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(total - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, $(dynamicSizeCache)));\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n      const windowStyle = computed(() => [\n        {\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        },\n        __spreadValues$1({\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        }, props.style)\n      ]);\n      const innerStyle = computed(() => {\n        const size = $(estimatedTotalSize);\n        const horizontal = $(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const {\n        onWheel\n      } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, (offset) => {\n        var _a, _b;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n      const emitEvents = () => {\n        const { total } = props;\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = $(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n        const { scrollDir, scrollOffset, updateRequested } = $(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n      const scrollVertically = (e) => {\n        const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollHorizontally = (e) => {\n        const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n        const { direction } = props;\n        let scrollOffset = scrollLeft;\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG: {\n              scrollOffset = -scrollLeft;\n              break;\n            }\n            case RTL_OFFSET_POS_DESC: {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n            }\n          }\n        }\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      const onScroll = (e) => {\n        $(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n      const scrollTo = (offset) => {\n        offset = Math.max(offset, 0);\n        if (offset === $(states).scrollOffset) {\n          return;\n        }\n        states.value = __spreadProps$1(__spreadValues$1({}, $(states)), {\n          scrollOffset: offset,\n          scrollDir: getScrollDir($(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const { scrollOffset } = $(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, $(dynamicSizeCache)));\n      };\n      const getItemStyle = (idx) => {\n        const { direction, itemSize, layout } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, $(dynamicSizeCache));\n          const size = getItemSize(props, idx, $(dynamicSizeCache));\n          const horizontal = $(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n        return style;\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (isServer)\n          return;\n        const { initScrollOffset } = props;\n        const windowElement = $(windowRef);\n        if (isNumber(initScrollOffset) && windowElement !== null) {\n          if ($(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const { direction, layout } = props;\n        const { scrollOffset, updateRequested } = $(states);\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\": {\n                  windowElement.scrollLeft = -scrollOffset;\n                  break;\n                }\n                case \"positive-ascending\": {\n                  windowElement.scrollLeft = scrollOffset;\n                  break;\n                }\n                default: {\n                  const { clientWidth, scrollWidth } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                  break;\n                }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n        visible: true\n      });\n      const listContainer = h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: \"el-vl__wrapper\"\n      }, [\n        listContainer,\n        scrollbar\n      ]);\n    }\n  });\n};\n\nconst FixedSizeList = createList({\n  name: \"ElFixedSizeList\",\n  getItemOffset: ({ itemSize }, index) => index * itemSize,\n  getItemSize: ({ itemSize }) => itemSize,\n  getEstimatedTotalSize: ({ total, itemSize }) => itemSize * total,\n  getOffset: ({ height, total, itemSize, layout, width }, index, alignment, scrollOffset) => {\n    const size = isHorizontal(layout) ? width : height;\n    if (process.env.ENV !== \"production\" && isString(size)) {\n      throwError(\"[ElVirtualList]\", `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `);\n    }\n    const lastItemOffset = Math.max(0, total * itemSize - size);\n    const maxOffset = Math.min(lastItemOffset, index * itemSize);\n    const minOffset = Math.max(0, (index + 1) * itemSize - size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset;\n      }\n      case END_ALIGNMENT: {\n        return minOffset;\n      }\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0;\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset;\n        } else {\n          return middleOffset;\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n    }\n  },\n  getStartIndexForOffset: ({ total, itemSize }, offset) => Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize))),\n  getStopIndexForStartIndex: ({ height, total, itemSize, layout, width }, startIndex, scrollOffset) => {\n    const offset = startIndex * itemSize;\n    const size = isHorizontal(layout) ? width : height;\n    const numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n  initCache() {\n    return void 0;\n  },\n  clearCache: true,\n  validateProps() {\n  }\n});\n\nconst SCOPE = \"ElDynamicSizeList\";\nconst getItemFromCache = (props, index, listCache) => {\n  const { itemSize } = props;\n  const { items, lastVisitedIndex } = listCache;\n  if (index > lastVisitedIndex) {\n    let offset = 0;\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = itemSize(i);\n      items[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    listCache.lastVisitedIndex = index;\n  }\n  return items[index];\n};\nconst findItem = (props, listCache, offset) => {\n  const { items, lastVisitedIndex } = listCache;\n  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\nconst bs = (props, listCache, low, high, offset) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, listCache).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n  return Math.max(0, low - 1);\n};\nconst es = (props, listCache, index, offset) => {\n  const { total } = props;\n  let exponent = 1;\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\nconst getEstimatedTotalSize = ({ total }, { items, estimatedItemSize, lastVisitedIndex }) => {\n  let totalSizeOfMeasuredItems = 0;\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n  const numUnmeasuredItems = total - lastVisitedIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\nconst DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: (props, index, listCache) => getItemFromCache(props, index, listCache).offset,\n  getItemSize: (_, index, { items }) => items[index].size,\n  getEstimatedTotalSize,\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const { height, layout, width } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, index, listCache);\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    const minOffset = Math.max(0, item.offset - size + item.size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset;\n      }\n      case END_ALIGNMENT: {\n        return minOffset;\n      }\n      case CENTERED_ALIGNMENT: {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n    }\n  },\n  getStartIndexForOffset: (props, offset, listCache) => findItem(props, listCache, offset),\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const { height, total, layout, width } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, startIndex, listCache);\n    const maxOffset = scrollOffset + size;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n    return stopIndex;\n  },\n  initCache({ estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n    cache.clearCacheAfterIndex = (index, forceUpdate = true) => {\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      instance.exposed.getItemStyleCache(-1);\n      if (forceUpdate) {\n        instance.proxy.$forceUpdate();\n      }\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: ({ itemSize }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `);\n      }\n    }\n  }\n});\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props;\n        const { isScrolling, xAxisScrollDir, scrollLeft } = $(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, $(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, $(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props;\n        const { isScrolling, yAxisScrollDir, scrollTop } = $(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, $(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, $(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, $(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, $(cache)));\n      const windowStyle = computed(() => [\n        {\n          position: \"relative\",\n          overflow: \"auto\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        },\n        __spreadValues$2({\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        }, props.style)\n      ]);\n      const innerStyle = computed(() => {\n        const width = `${$(estimatedTotalWidth)}px`;\n        const height = `${$(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props;\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = $(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = $(rowsToRender);\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n        const { scrollLeft, scrollTop, updateRequested, xAxisScrollDir, yAxisScrollDir } = $(states);\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n      const onScroll = (e) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n        let _scrollLeft = scrollLeft;\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n      const scrollTo = ({\n        scrollLeft,\n        scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n        const _states = $(states);\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = $(states);\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth();\n        const _cache = $(cache);\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const { columnWidth, direction, rowHeight } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, $(cache));\n          const _cache = $(cache);\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (isServer)\n          return;\n        const { initScrollLeft, initScrollTop } = props;\n        const windowElement = $(windowRef);\n        if (windowElement !== null) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const { direction } = props;\n        const { scrollLeft, scrollTop, updateRequested } = $(states);\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft;\n                break;\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft;\n                break;\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement;\n                windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      const api = {\n        windowStyle,\n        windowRef,\n        columnsToRender,\n        innerRef,\n        innerStyle,\n        states,\n        rowsToRender,\n        getItemStyle,\n        onScroll,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        containerElement,\n        columnsToRender,\n        data,\n        getItemStyle,\n        innerElement,\n        innerStyle,\n        rowsToRender,\n        onScroll,\n        states,\n        useIsScrolling,\n        windowStyle,\n        totalColumn,\n        totalRow\n      } = ctx;\n      const [columnStart, columnEnd] = columnsToRender;\n      const [rowStart, rowEnd] = rowsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (totalRow > 0 && totalColumn > 0) {\n        for (let row = rowStart; row <= rowEnd; row++) {\n          for (let column = columnStart; column <= columnEnd; column++) {\n            children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n              columnIndex: column,\n              data,\n              key: column,\n              isScrolling: useIsScrolling ? states.isScrolling : void 0,\n              style: getItemStyle(row, column),\n              rowIndex: row\n            }));\n          }\n        }\n      }\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      return h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        ref: \"windowRef\"\n      }, !isString(Container) ? { default: () => InnerNode } : InnerNode);\n    }\n  });\n};\n\nconst SCOPE$1 = \"ElFixedSizeGrid\";\nconst FixedSizeGrid = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: ({ columnWidth }, index) => [\n    columnWidth,\n    index * columnWidth\n  ],\n  getRowPosition: ({ rowHeight }, index) => [\n    rowHeight,\n    index * rowHeight\n  ],\n  getEstimatedTotalHeight: ({ totalRow, rowHeight }) => rowHeight * totalRow,\n  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) => columnWidth * totalColumn,\n  getColumnOffset: ({ totalColumn, columnWidth, width }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {\n    width = Number(width);\n    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0;\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset;\n        } else {\n          return middleOffset;\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getRowOffset: ({ rowHeight, height, totalRow }, rowIndex, align, scrollTop, _, scrollBarWidth) => {\n    height = Number(height);\n    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0;\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset;\n        } else {\n          return middleOffset;\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),\n  getColumnStopIndexForStartIndex: ({ columnWidth, totalColumn, width }, startIndex, scrollLeft) => {\n    const left = startIndex * columnWidth;\n    const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: ({ rowHeight, totalRow }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),\n  getRowStopIndexForStartIndex: ({ rowHeight, totalRow, height }, startIndex, scrollTop) => {\n    const top = startIndex * rowHeight;\n    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: () => void 0,\n  clearCache: true,\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\n\nconst { max, min, floor } = Math;\nconst SCOPE$2 = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\nconst getItemFromCache$1 = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [\n    gridCache[type],\n    props[ACCESS_SIZER_KEY_MAP[type]],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]\n  ];\n  if (index > lastVisited) {\n    let offset = 0;\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n  return cachedItems[index];\n};\nconst bs$1 = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache$1(props, mid, gridCache, type).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return max(0, low - 1);\n};\nconst es$1 = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n  while (idx < total && getItemFromCache$1(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n  return bs$1(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\nconst findItem$1 = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [\n    gridCache[type],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]\n  ];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n  if (lastVisitedItemOffset >= offset) {\n    return bs$1(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n  return es$1(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\nconst getEstimatedTotalHeight = ({ totalRow }, {\n  estimatedRowHeight,\n  lastVisitedRowIndex,\n  row\n}) => {\n  let sizeOfVisitedRows = 0;\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\nconst getEstimatedTotalWidth = ({\n  totalColumn\n}, {\n  column,\n  estimatedColumnWidth,\n  lastVisitedColumnIndex\n}) => {\n  let sizeOfVisitedColumns = 0;\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [\n    size,\n    estimatedSizeAssociates\n  ] = [\n    type === \"row\" ? props.height : props.width,\n    ACCESS_ESTIMATED_SIZE_KEY_MAP[type]\n  ];\n  const item = getItemFromCache$1(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n  switch (alignment) {\n    case START_ALIGNMENT: {\n      return maxOffset;\n    }\n    case END_ALIGNMENT: {\n      return minOffset;\n    }\n    case CENTERED_ALIGNMENT: {\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n    }\n    case AUTO_ALIGNMENT:\n    default: {\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n};\nconst FixedSizeGrid$1 = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem$1(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache$1(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, startIndex, cache, \"column\").size;\n    }\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem$1(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const { totalRow, height } = props;\n    const item = getItemFromCache$1(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, stopIndex, cache, \"row\").size;\n    }\n    return stopIndex;\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: true,\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\n\nexport { FixedSizeGrid$1 as DynamicSizeGrid, DynamicSizeList, FixedSizeGrid, FixedSizeList };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}