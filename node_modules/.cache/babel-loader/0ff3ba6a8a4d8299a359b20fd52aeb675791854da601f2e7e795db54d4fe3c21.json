{"ast":null,"code":"const EVENT_CODE = {\n  tab: 'Tab',\n  enter: 'Enter',\n  space: 'Space',\n  left: 'ArrowLeft',\n  up: 'ArrowUp',\n  right: 'ArrowRight',\n  down: 'ArrowDown',\n  esc: 'Escape',\n  delete: 'Delete',\n  backspace: 'Backspace'\n};\nconst FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`;\nconst isVisible = element => {\n  if (process.env.NODE_ENV === 'test') return true;\n  const computed = getComputedStyle(element);\n  return computed.position === 'fixed' ? false : element.offsetParent !== null;\n};\nconst obtainAllFocusableElements = element => {\n  return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter(isFocusable).filter(isVisible);\n};\nconst isFocusable = element => {\n  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute('tabIndex') !== null) {\n    return true;\n  }\n  if (element.disabled) {\n    return false;\n  }\n  switch (element.nodeName) {\n    case 'A':\n      {\n        return !!element.href && element.rel !== 'ignore';\n      }\n    case 'INPUT':\n      {\n        return !(element.type === 'hidden' || element.type === 'file');\n      }\n    case 'BUTTON':\n    case 'SELECT':\n    case 'TEXTAREA':\n      {\n        return true;\n      }\n    default:\n      {\n        return false;\n      }\n  }\n};\nconst attemptFocus = element => {\n  var _a;\n  if (!isFocusable(element)) {\n    return false;\n  }\n  Utils.IgnoreUtilFocusChanges = true;\n  (_a = element.focus) === null || _a === void 0 ? void 0 : _a.call(element);\n  Utils.IgnoreUtilFocusChanges = false;\n  return document.activeElement === element;\n};\nconst triggerEvent = function (elm, name, ...opts) {\n  let eventName;\n  if (name.includes('mouse') || name.includes('click')) {\n    eventName = 'MouseEvents';\n  } else if (name.includes('key')) {\n    eventName = 'KeyboardEvent';\n  } else {\n    eventName = 'HTMLEvents';\n  }\n  const evt = document.createEvent(eventName);\n  evt.initEvent(name, ...opts);\n  elm.dispatchEvent(evt);\n  return elm;\n};\nconst Utils = {\n  IgnoreUtilFocusChanges: false,\n  focusFirstDescendant: function (element) {\n    for (let i = 0; i < element.childNodes.length; i++) {\n      const child = element.childNodes[i];\n      if (attemptFocus(child) || this.focusFirstDescendant(child)) {\n        return true;\n      }\n    }\n    return false;\n  },\n  focusLastDescendant: function (element) {\n    for (let i = element.childNodes.length - 1; i >= 0; i--) {\n      const child = element.childNodes[i];\n      if (attemptFocus(child) || this.focusLastDescendant(child)) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\nexport default Utils;\nexport { EVENT_CODE, attemptFocus, isFocusable, isVisible, obtainAllFocusableElements, triggerEvent };","map":{"version":3,"names":["EVENT_CODE","tab","enter","space","left","up","right","down","esc","delete","backspace","FOCUSABLE_ELEMENT_SELECTORS","isVisible","element","process","env","NODE_ENV","computed","getComputedStyle","position","offsetParent","obtainAllFocusableElements","Array","from","querySelectorAll","filter","isFocusable","tabIndex","getAttribute","disabled","nodeName","href","rel","type","attemptFocus","_a","Utils","IgnoreUtilFocusChanges","focus","call","document","activeElement","triggerEvent","elm","name","opts","eventName","includes","evt","createEvent","initEvent","dispatchEvent","focusFirstDescendant","i","childNodes","length","child","focusLastDescendant"],"sources":["/home/jisra/Documents/escom/web/tecweb_vue_frontend/node_modules/element-plus/es/utils/aria.js"],"sourcesContent":["const EVENT_CODE = {\r\n    tab: 'Tab',\r\n    enter: 'Enter',\r\n    space: 'Space',\r\n    left: 'ArrowLeft',\r\n    up: 'ArrowUp',\r\n    right: 'ArrowRight',\r\n    down: 'ArrowDown',\r\n    esc: 'Escape',\r\n    delete: 'Delete',\r\n    backspace: 'Backspace',\r\n};\r\nconst FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`;\r\nconst isVisible = (element) => {\r\n    if (process.env.NODE_ENV === 'test')\r\n        return true;\r\n    const computed = getComputedStyle(element);\r\n    return computed.position === 'fixed' ? false : element.offsetParent !== null;\r\n};\r\nconst obtainAllFocusableElements = (element) => {\r\n    return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter(isFocusable)\r\n        .filter(isVisible);\r\n};\r\nconst isFocusable = (element) => {\r\n    if (element.tabIndex > 0 ||\r\n        (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)) {\r\n        return true;\r\n    }\r\n    if (element.disabled) {\r\n        return false;\r\n    }\r\n    switch (element.nodeName) {\r\n        case 'A': {\r\n            return !!element.href && element.rel !== 'ignore';\r\n        }\r\n        case 'INPUT': {\r\n            return !(element.type === 'hidden' || element.type === 'file');\r\n        }\r\n        case 'BUTTON':\r\n        case 'SELECT':\r\n        case 'TEXTAREA': {\r\n            return true;\r\n        }\r\n        default: {\r\n            return false;\r\n        }\r\n    }\r\n};\r\nconst attemptFocus = (element) => {\r\n    var _a;\r\n    if (!isFocusable(element)) {\r\n        return false;\r\n    }\r\n    Utils.IgnoreUtilFocusChanges = true;\r\n    (_a = element.focus) === null || _a === void 0 ? void 0 : _a.call(element);\r\n    Utils.IgnoreUtilFocusChanges = false;\r\n    return document.activeElement === element;\r\n};\r\nconst triggerEvent = function (elm, name, ...opts) {\r\n    let eventName;\r\n    if (name.includes('mouse') || name.includes('click')) {\r\n        eventName = 'MouseEvents';\r\n    }\r\n    else if (name.includes('key')) {\r\n        eventName = 'KeyboardEvent';\r\n    }\r\n    else {\r\n        eventName = 'HTMLEvents';\r\n    }\r\n    const evt = document.createEvent(eventName);\r\n    evt.initEvent(name, ...opts);\r\n    elm.dispatchEvent(evt);\r\n    return elm;\r\n};\r\nconst Utils = {\r\n    IgnoreUtilFocusChanges: false,\r\n    focusFirstDescendant: function (element) {\r\n        for (let i = 0; i < element.childNodes.length; i++) {\r\n            const child = element.childNodes[i];\r\n            if (attemptFocus(child) ||\r\n                this.focusFirstDescendant(child)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    focusLastDescendant: function (element) {\r\n        for (let i = element.childNodes.length - 1; i >= 0; i--) {\r\n            const child = element.childNodes[i];\r\n            if (attemptFocus(child) ||\r\n                this.focusLastDescendant(child)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n};\n\nexport default Utils;\nexport { EVENT_CODE, attemptFocus, isFocusable, isVisible, obtainAllFocusableElements, triggerEvent };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}